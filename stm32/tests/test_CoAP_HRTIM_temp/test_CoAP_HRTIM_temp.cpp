/*
 * Copyright (c) 2014 ELL-i co-op.
 *
 * This is part of ELL-i software.
 *
 * ELL-i software is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ELL-i software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ELL-i software.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <assert.h>
#include <stddef.h>
#include <string.h>
#include <encX24j600/ENCX24J600.h>
#include <ethernet.h>
#include <ip.h>
#include <udp.h>
#include <coap_internal.h>

#define DEBUG_LED 4

typedef struct valid_range {
    uint16_t min;
    uint16_t max;
} valid_range;

const valid_range limits[8] = {
    {0x0060, 0xFFDF},
    {0x0030, 0xFFEF},
    {0x0018, 0xFFF7},
    {0x000C, 0xFFFB},
    {0x0006, 0xFFFD},
    {0x0003, 0xFFFD},
    {0x0003, 0xFFFD},
    {0x0003, 0xFFFD},
};

const uint32_t prescaler = 0;
const uint16_t period = 16384;

const uint16_t lut_r[256] = {
0x0   , 0x1B  , 0x36  , 0x51  , 0x6C  , 0x87  , 0xA2  , 0xBD  ,
0xD8  , 0xF3  , 0x10E , 0x129 , 0x144 , 0x15F , 0x17A , 0x195 ,
0x1B0 , 0x1CB , 0x1E6 , 0x201 , 0x21C , 0x237 , 0x252 , 0x26D ,
0x288 , 0x2A3 , 0x2BE , 0x2D9 , 0x2F4 , 0x30F , 0x32A , 0x345 ,
0x35F , 0x37A , 0x395 , 0x3B0 , 0x3CB , 0x3E6 , 0x401 , 0x41C ,
0x437 , 0x452 , 0x46D , 0x488 , 0x4A3 , 0x4BE , 0x4D9 , 0x4F4 ,
0x50F , 0x52A , 0x545 , 0x560 , 0x57B , 0x596 , 0x5B1 , 0x5CC ,
0x5E7 , 0x602 , 0x61D , 0x638 , 0x653 , 0x66E , 0x689 , 0x6A4 ,
0x6D8 , 0x70B , 0x73F , 0x772 , 0x7A6 , 0x7D9 , 0x80D , 0x841 ,
0x874 , 0x8A8 , 0x8DB , 0x90F , 0x942 , 0x976 , 0x9A9 , 0x9DD ,
0xA11 , 0xA44 , 0xA78 , 0xAAB , 0xADF , 0xB12 , 0xB46 , 0xB7A ,
0xBAD , 0xBE1 , 0xC14 , 0xC48 , 0xC7B , 0xCAF , 0xCE2 , 0xD16 ,
0xD4A , 0xD7D , 0xDB1 , 0xDE4 , 0xE18 , 0xE4B , 0xE7F , 0xEB3 ,
0xEE6 , 0xF1A , 0xF4D , 0xF81 , 0xFB4 , 0xFE8 , 0x101B, 0x104F,
0x1083, 0x10B6, 0x10EA, 0x111D, 0x1151, 0x1184, 0x11B8, 0x11EC,
0x121F, 0x1253, 0x1286, 0x12BA, 0x12ED, 0x1321, 0x1354, 0x1388,
0x13C7, 0x1405, 0x1444, 0x1482, 0x14C1, 0x14FF, 0x153E, 0x157C,
0x15BB, 0x15F9, 0x1638, 0x1676, 0x16B5, 0x16F3, 0x1732, 0x1770,
0x17AF, 0x17ED, 0x182C, 0x186A, 0x18A9, 0x18E7, 0x1926, 0x1964,
0x19A3, 0x19E1, 0x1A20, 0x1A5E, 0x1A9D, 0x1ADB, 0x1B1A, 0x1B58,
0x1B97, 0x1BD5, 0x1C14, 0x1C52, 0x1C91, 0x1CCF, 0x1D0E, 0x1D4C,
0x1D8B, 0x1DC9, 0x1E08, 0x1E46, 0x1E85, 0x1EC3, 0x1F02, 0x1F40,
0x1F7F, 0x1FBD, 0x1FFC, 0x203A, 0x2079, 0x20B7, 0x20F6, 0x2134,
0x2173, 0x21B1, 0x21F0, 0x222E, 0x226D, 0x22AB, 0x22EA, 0x2328,
0x2362, 0x239C, 0x23D5, 0x240F, 0x2449, 0x2483, 0x24BD, 0x24F7,
0x2530, 0x256A, 0x25A4, 0x25DE, 0x2618, 0x2651, 0x268B, 0x26C5,
0x26FF, 0x2739, 0x2772, 0x27AC, 0x27E6, 0x2820, 0x285A, 0x2894,
0x28CD, 0x2907, 0x2941, 0x297B, 0x29B5, 0x29EE, 0x2A28, 0x2A62,
0x2A9C, 0x2AD6, 0x2B0F, 0x2B49, 0x2B83, 0x2BBD, 0x2BF7, 0x2C31,
0x2C6A, 0x2CA4, 0x2CDE, 0x2D18, 0x2D52, 0x2D8B, 0x2DC5, 0x2DFF,
0x2E39, 0x2E73, 0x2EAC, 0x2EE6, 0x2F20, 0x2F5A, 0x2F94, 0x2FCE,
0x3007, 0x3041, 0x307B, 0x30B5, 0x30EF, 0x3128, 0x3162, 0x319C,
};

const uint16_t lut_g[256] = {
0x0   , 0x41  , 0x81  , 0xC2  , 0x103 , 0x143 , 0x184 , 0x1C4 ,
0x205 , 0x246 , 0x286 , 0x2C7 , 0x308 , 0x348 , 0x389 , 0x3CA ,
0x40A , 0x44B , 0x48B , 0x4CC , 0x50D , 0x54D , 0x58E , 0x5CF ,
0x60F , 0x650 , 0x691 , 0x6D1 , 0x712 , 0x752 , 0x793 , 0x7D4 ,
0x814 , 0x855 , 0x896 , 0x8D6 , 0x917 , 0x957 , 0x998 , 0x9D9 ,
0xA19 , 0xA5A , 0xA9B , 0xADB , 0xB1C , 0xB5D , 0xB9D , 0xBDE ,
0xC1E , 0xC5F , 0xCA0 , 0xCE0 , 0xD21 , 0xD62 , 0xDA2 , 0xDE3 ,
0xE24 , 0xE64 , 0xEA5 , 0xEE5 , 0xF26 , 0xF67 , 0xFA7 , 0xFE8 ,
0x1028, 0x1067, 0x10A7, 0x10E7, 0x1126, 0x1166, 0x11A5, 0x11E5,
0x1225, 0x1264, 0x12A4, 0x12E4, 0x1323, 0x1363, 0x13A2, 0x13E2,
0x1422, 0x1461, 0x14A1, 0x14E1, 0x1520, 0x1560, 0x159F, 0x15DF,
0x161F, 0x165E, 0x169E, 0x16DE, 0x171D, 0x175D, 0x179C, 0x17DC,
0x181C, 0x185B, 0x189B, 0x18DB, 0x191A, 0x195A, 0x1999, 0x19D9,
0x1A19, 0x1A58, 0x1A98, 0x1AD8, 0x1B17, 0x1B57, 0x1B96, 0x1BD6,
0x1C16, 0x1C55, 0x1C95, 0x1CD5, 0x1D14, 0x1D54, 0x1D93, 0x1DD3,
0x1E13, 0x1E52, 0x1E92, 0x1ED2, 0x1F11, 0x1F51, 0x1F90, 0x1FD0,
0x2010, 0x204F, 0x208F, 0x20CF, 0x210E, 0x214E, 0x218D, 0x21CD,
0x220D, 0x224C, 0x228C, 0x22CC, 0x230B, 0x234B, 0x238A, 0x23CA,
0x240A, 0x2449, 0x2489, 0x24C9, 0x2508, 0x2548, 0x2587, 0x25C7,
0x2607, 0x2646, 0x2686, 0x26C6, 0x2705, 0x2745, 0x2784, 0x27C4,
0x2804, 0x2843, 0x2883, 0x28C3, 0x2902, 0x2942, 0x2981, 0x29C1,
0x2A01, 0x2A40, 0x2A80, 0x2AC0, 0x2AFF, 0x2B3F, 0x2B7E, 0x2BBE,
0x2BFE, 0x2C3D, 0x2C7D, 0x2CBD, 0x2CFC, 0x2D3C, 0x2D7B, 0x2DBB,
0x2DFB, 0x2E3A, 0x2E7A, 0x2EBA, 0x2EF9, 0x2F39, 0x2F78, 0x2FB8,
0x2FF8, 0x3037, 0x3077, 0x30B7, 0x30F6, 0x3136, 0x3175, 0x31B5,
0x31F5, 0x3234, 0x3274, 0x32B4, 0x32F3, 0x3333, 0x3372, 0x33B2,
0x33F2, 0x3431, 0x3471, 0x34B1, 0x34F0, 0x3530, 0x356F, 0x35AF,
0x35EF, 0x362E, 0x366E, 0x36AE, 0x36ED, 0x372D, 0x376C, 0x37AC,
0x37EC, 0x382B, 0x386B, 0x38AB, 0x38EA, 0x392A, 0x3969, 0x39A9,
0x39E9, 0x3A28, 0x3A68, 0x3AA8, 0x3AE7, 0x3B27, 0x3B66, 0x3BA6,
0x3BE6, 0x3C25, 0x3C65, 0x3CA5, 0x3CE4, 0x3D24, 0x3D63, 0x3DA3,
0x3DE3, 0x3E22, 0x3E62, 0x3EA2, 0x3EE1, 0x3F21, 0x3F60, 0x3FA0,
};

const uint16_t lut_b[256] = {
0x0   , 0x2B  , 0x56  , 0x81  , 0xAB  , 0xD6  , 0x101 , 0x12C ,
0x157 , 0x182 , 0x1AD , 0x1D7 , 0x202 , 0x22D , 0x258 , 0x283 ,
0x2AE , 0x2D9 , 0x303 , 0x32E , 0x359 , 0x384 , 0x3AF , 0x3DA ,
0x405 , 0x42F , 0x45A , 0x485 , 0x4B0 , 0x4DB , 0x506 , 0x531 ,
0x55B , 0x586 , 0x5B1 , 0x5DC , 0x607 , 0x632 , 0x65D , 0x687 ,
0x6B2 , 0x6DD , 0x708 , 0x733 , 0x75E , 0x789 , 0x7B3 , 0x7DE ,
0x809 , 0x834 , 0x85F , 0x88A , 0x8B5 , 0x8DF , 0x90A , 0x935 ,
0x960 , 0x98B , 0x9B6 , 0x9E1 , 0xA0B , 0xA36 , 0xA61 , 0xA8C ,
0xAC0 , 0xAF3 , 0xB27 , 0xB5A , 0xB8E , 0xBC1 , 0xBF5 , 0xC29 ,
0xC5C , 0xC90 , 0xCC3 , 0xCF7 , 0xD2A , 0xD5E , 0xD91 , 0xDC5 ,
0xDF9 , 0xE2C , 0xE60 , 0xE93 , 0xEC7 , 0xEFA , 0xF2E , 0xF62 ,
0xF95 , 0xFC9 , 0xFFC , 0x1030, 0x1063, 0x1097, 0x10CA, 0x10FE,
0x1132, 0x1165, 0x1199, 0x11CC, 0x1200, 0x1233, 0x1267, 0x129B,
0x12CE, 0x1302, 0x1335, 0x1369, 0x139C, 0x13D0, 0x1403, 0x1437,
0x146B, 0x149E, 0x14D2, 0x1505, 0x1539, 0x156C, 0x15A0, 0x15D4,
0x1607, 0x163B, 0x166E, 0x16A2, 0x16D5, 0x1709, 0x173C, 0x1770,
0x17B6, 0x17FD, 0x1843, 0x1889, 0x18D0, 0x1916, 0x195C, 0x19A3,
0x19E9, 0x1A2F, 0x1A75, 0x1ABC, 0x1B02, 0x1B48, 0x1B8F, 0x1BD5,
0x1C1B, 0x1C62, 0x1CA8, 0x1CEE, 0x1D35, 0x1D7B, 0x1DC1, 0x1E08,
0x1E4E, 0x1E94, 0x1EDA, 0x1F21, 0x1F67, 0x1FAD, 0x1FF4, 0x203A,
0x2080, 0x20C7, 0x210D, 0x2153, 0x219A, 0x21E0, 0x2226, 0x226D,
0x22B3, 0x22F9, 0x233F, 0x2386, 0x23CC, 0x2412, 0x2459, 0x249F,
0x24E5, 0x252C, 0x2572, 0x25B8, 0x25FF, 0x2645, 0x268B, 0x26D2,
0x2718, 0x275E, 0x27A4, 0x27EB, 0x2831, 0x2877, 0x28BE, 0x2904,
0x295E, 0x29B9, 0x2A13, 0x2A6E, 0x2AC8, 0x2B23, 0x2B7D, 0x2BD8,
0x2C32, 0x2C8C, 0x2CE7, 0x2D41, 0x2D9C, 0x2DF6, 0x2E51, 0x2EAB,
0x2F05, 0x2F60, 0x2FBA, 0x3015, 0x306F, 0x30CA, 0x3124, 0x317F,
0x31D9, 0x3233, 0x328E, 0x32E8, 0x3343, 0x339D, 0x33F8, 0x3452,
0x34AC, 0x3507, 0x3561, 0x35BC, 0x3616, 0x3671, 0x36CB, 0x3726,
0x3780, 0x37DA, 0x3835, 0x388F, 0x38EA, 0x3944, 0x399F, 0x39F9,
0x3A53, 0x3AAE, 0x3B08, 0x3B63, 0x3BBD, 0x3C18, 0x3C72, 0x3CCD,
0x3D27, 0x3D81, 0x3DDC, 0x3E36, 0x3E91, 0x3EEB, 0x3F46, 0x3FA0,
};

uint8_t address[ETHER_ADDR_LEN];
uint8_t buffer[2048 + 8/*XXX*/] __attribute__((aligned(8)));
struct ether_header *const ether_header = (struct ether_header *)(buffer+8);

extern "C" void debug_write(int c) {
    Serial.write(c);
}

extern "C" void debug_write_hex(unsigned int c) {
    Serial.writeHex(c);
}

void setup() {

    pinMode(DEBUG_LED, OUTPUT);
    Serial.begin(57600);
    Serial.write('L');

    /* In DM00121475.pdf it is specified that the
     * HRTIM clock source should be set before
     * enabling the HRTIM in the enable register.
     */

    /* Configure Clock Source to PLL vco */
    RCC->CFGR3 |= RCC_CFGR3_HRTIM1SW;

    /* Enable HRTIM1 */
    RCC->APB2ENR |= RCC_APB2ENR_HRTIM1EN;

    /* For now, only the case where all the prescalers
     * (for Master and A to E) are set to the same value.
     * If no events were to be propagated between
     * timers, then it would be safe to configure
     * different prescaler ratios (RM0364 Reference
     * Manual, p.627, Rev1, DM00093941.pdf)
     */

    /* Configure prescalers before enabling the timers.
     * Selected prescaler = 1 (000), Max Resolution.
     * HRCK = HRTIM * 32 = PLL * 2 * 32
     */

    /* The first phase is alwasy zero, as it is the reference */
    const uint16_t phases[5] = {0, 5461, 0, 0, 10923};

    /* Randomly selected low value */
    const uint16_t duties[5] = {10, 10, 10, 10, 10};

    /* Calibration initialisation, periodicity set to highest */
    HRTIM1->sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL;
    while (!(HRTIM1->sCommonRegs.ISR & HRTIM_ISR_DLLRDY))
        ;
    HRTIM1->sCommonRegs.DLLCR = HRTIM_DLLCR_CALRTE | HRTIM_DLLCR_CALEN;

    /* Disable preload */
    HRTIM1->sMasterRegs.MCR &= ~HRTIM_MCR_PREEN;

    /* Write prescaler */
    HRTIM1->sMasterRegs.MCR &= ~HRTIM_MCR_CK_PSC;
    HRTIM1->sMasterRegs.MCR |= prescaler;
    for (int i = 0; i < 5; i++) {
        HRTIM1->sTimerxRegs[i].TIMxCR &= ~HRTIM_TIMCR_CK_PSC;
        HRTIM1->sTimerxRegs[i].TIMxCR |= prescaler;
    }

    /* Configure master timer as Continuous mode */
    HRTIM1->sMasterRegs.MCR |= HRTIM_MCR_CONT;

    /* Configure the slave timers as Single-shot Retriggerable */
    for (int i = 0; i < 5; i++) {
        HRTIM1->sTimerxRegs[i].TIMxCR &= ~HRTIM_TIMCR_CONT;
        HRTIM1->sTimerxRegs[i].TIMxCR |=  HRTIM_TIMCR_RETRIG;
    }

    /* Configure periods */
    HRTIM1->sMasterRegs.MPER = (uint32_t)period;
    for (int i = 0; i < 5; i++) {
        HRTIM1->sTimerxRegs[i].PERxR = (uint32_t)period;
    }

    /* Configure phases, phase[0] as reference */
    HRTIM1->sMasterRegs.MCMP1R = (uint32_t)phases[1];
    HRTIM1->sMasterRegs.MCMP2R = (uint32_t)phases[2];
    HRTIM1->sMasterRegs.MCMP3R = (uint32_t)phases[3];
    HRTIM1->sMasterRegs.MCMP4R = (uint32_t)phases[4];

    /* Connect timers reset with master compare */
    HRTIM1->sTimerxRegs[0].RSTxR = HRTIM_RSTR_MSTPER;
    HRTIM1->sTimerxRegs[1].RSTxR = HRTIM_RSTR_MSTCMP1;
    HRTIM1->sTimerxRegs[2].RSTxR = HRTIM_RSTR_MSTCMP2;
    HRTIM1->sTimerxRegs[3].RSTxR = HRTIM_RSTR_MSTCMP3;
    HRTIM1->sTimerxRegs[4].RSTxR = HRTIM_RSTR_MSTCMP4;

    /* Configure duty cycles, and ouptput set */
    for (int i = 0; i < 5; i++) {
        HRTIM1->sTimerxRegs[i].CMP1xR = (uint32_t)(period - duties[i]);
        HRTIM1->sTimerxRegs[i].SETx1R = HRTIM_SET1R_CMP1;
    }

    /* Configure ouptput reset */
    HRTIM1->sTimerxRegs[0].RSTx1R = HRTIM_RST1R_PER | HRTIM_RST1R_MSTPER;
    HRTIM1->sTimerxRegs[1].RSTx1R = HRTIM_RST1R_PER | HRTIM_RST1R_MSTCMP1;
    HRTIM1->sTimerxRegs[2].RSTx1R = HRTIM_RST1R_PER | HRTIM_RST1R_MSTCMP2;
    HRTIM1->sTimerxRegs[3].RSTx1R = HRTIM_RST1R_PER | HRTIM_RST1R_MSTCMP3;
    HRTIM1->sTimerxRegs[4].RSTx1R = HRTIM_RST1R_PER | HRTIM_RST1R_MSTCMP4;

    /* Enable outputs */
    HRTIM1->sCommonRegs.OENR = HRTIM_OENR_TA1OEN | HRTIM_OENR_TB1OEN |
                               HRTIM_OENR_TC1OEN | HRTIM_OENR_TD1OEN |
                               HRTIM_OENR_TE1OEN;

    /* Enable master and all slaves */
    HRTIM1->sMasterRegs.MCR |= HRTIM_MCR_MCEN  | HRTIM_MCR_TACEN |
                               HRTIM_MCR_TBCEN | HRTIM_MCR_TCCEN |
                               HRTIM_MCR_TDCEN | HRTIM_MCR_TECEN;

    Serial.write('B');
    ETHERNET.begin();
    ETHERNET.readEthernetAddr(address);
    eth_set_address(address);
    ETHERNET.enableInterrupt(PKT_IE);
    ETHERNET.enableGlobalInterrupts();
    Serial.write('s');
    Serial.write('\r');
    Serial.write('\n');
}

void loop() {
    Serial.write('w');
    while (digitalRead(ETHERNET.int_pin_))
        ;

    Serial.write('r');
    digitalWrite(DEBUG_LED, 1);
    ETHERNET.receivePacket(&buffer[8], sizeof(buffer) - 8);
    Serial.write('.');
    eth_input(ether_header);
    digitalWrite(DEBUG_LED, 0);
    Serial.write('\r');
    Serial.write('\n');

#ifdef EMULATOR
    _exit(0);
#endif
}

#include <CoAP.h>

#define SUCCESS_STRING "Success"
#define ERROR_STRING   "Error"

int leds_put_callback(
    const struct coap_options *input_options,
    const uint8_t *input_buffer, size_t input_length,
    uint8_t *output_buffer, size_t *output_buffer_length) {
    if (input_length != 3) {
        goto error;
    }
    HRTIM1->sTimerxRegs[0].CMP1xR = (uint32_t)(period - lut_g[input_buffer[1]/2]);
    HRTIM1->sTimerxRegs[1].CMP1xR = (uint32_t)(period - lut_r[input_buffer[0]/2]);
    HRTIM1->sTimerxRegs[4].CMP1xR = (uint32_t)(period - lut_b[input_buffer[2]/2]);

#if 0
    Serial.write('\r');
    Serial.write('\n');
    Serial.write('"');
    while (input_length--) {
        //Serial.write(*input_buffer++);
        Serial.writeHex(*input_buffer++);
        Serial.write('|');
    }
    Serial.write('"');

#endif
    *output_buffer++ = COAP_OPTION_PAYLOAD;
    memcpy(output_buffer, SUCCESS_STRING, sizeof(SUCCESS_STRING));
    *output_buffer_length = sizeof(SUCCESS_STRING); // Excludes NUL
    return COAP_CODE_CHANGED;
error:
    *output_buffer++ = COAP_OPTION_PAYLOAD;
    memcpy(output_buffer, ERROR_STRING, sizeof(ERROR_STRING));
    *output_buffer_length = sizeof(ERROR_STRING); // Excludes NUL
    return COAP_CODE_CHANGED;
}


DEFINE_COAP_URL(leds, "leds", NULL, leds_put_callback);
